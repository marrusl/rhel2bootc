"""
Containerfile renderer: produces Containerfile and config/ tree from snapshot.
"""

from pathlib import Path
from typing import Optional

from jinja2 import Environment

from ..schema import ConfigFileKind, InspectionSnapshot


def _base_image_from_os_release(snapshot: InspectionSnapshot) -> str:
    """Return FROM line base image based on os_release."""
    if not snapshot.os_release:
        return "registry.redhat.io/rhel9/rhel-bootc:9.6"
    osr = snapshot.os_release
    if osr.id == "rhel" and osr.version_id:
        return f"registry.redhat.io/rhel9/rhel-bootc:{osr.version_id}"
    if "centos" in osr.id.lower():
        return "quay.io/centos-bootc/centos-bootc:stream9"
    return "registry.redhat.io/rhel9/rhel-bootc:9.6"


def _write_config_tree(snapshot: InspectionSnapshot, output_dir: Path) -> None:
    """Write all config files from snapshot to output_dir/config/ preserving paths."""
    config_dir = output_dir / "config"
    if snapshot.config and snapshot.config.files:
        for entry in snapshot.config.files:
            rel = entry.path.lstrip("/")
            dest = config_dir / rel
            dest.parent.mkdir(parents=True, exist_ok=True)
            dest.write_text(entry.content or "")

    if snapshot.rpm and snapshot.rpm.repo_files:
        for repo in snapshot.rpm.repo_files:
            dest = config_dir / repo.path
            dest.parent.mkdir(parents=True, exist_ok=True)
            dest.write_text(repo.content or "")

    # Firewalld zones/services
    if snapshot.network and snapshot.network.firewall_zones:
        for z in snapshot.network.firewall_zones:
            path = z.get("path", "")
            content = z.get("content", "")
            if path:
                dest = config_dir / path
                dest.parent.mkdir(parents=True, exist_ok=True)
                dest.write_text(content)

    # Generated timer units from cron
    if snapshot.scheduled_tasks and snapshot.scheduled_tasks.generated_timer_units:
        systemd_dir = config_dir / "etc/systemd/system"
        systemd_dir.mkdir(parents=True, exist_ok=True)
        for u in snapshot.scheduled_tasks.generated_timer_units:
            name = u.get("name", "cron-timer")
            (systemd_dir / f"{name}.timer").write_text(u.get("timer_content", ""))
            (systemd_dir / f"{name}.service").write_text(u.get("service_content", ""))

    # Quadlet units (content from inspector; older snapshots may have path/name only)
    if snapshot.containers and snapshot.containers.quadlet_units:
        quadlet_dir = output_dir / "quadlet"
        quadlet_dir.mkdir(parents=True, exist_ok=True)
        for u in snapshot.containers.quadlet_units:
            name = u.get("name", "")
            content = u.get("content", "")
            if name and content:
                (quadlet_dir / name).write_text(content)

    # tmpfiles.d for /var (and home) directory structure
    tmpfiles_dir = config_dir / "etc/tmpfiles.d"
    tmpfiles_dir.mkdir(parents=True, exist_ok=True)
    tmpfiles_lines = [
        "# Generated by rhel2bootc: directories created on every boot.",
        "# /var is seeded at initial bootstrap only; bootc does not update it.",
        "# Add d lines for application dirs under /var or /home as needed.",
    ]
    if snapshot.users_groups and snapshot.users_groups.users:
        for u in snapshot.users_groups.users[:20]:
            name = u.get("name", "")
            if name and name != "root":
                tmpfiles_lines.append(f"d /home/{name} 0755 {name} - -")
    if len(tmpfiles_lines) <= 3:
        tmpfiles_lines.append("d /var/lib/app 0755 root root -")
    (tmpfiles_dir / "rhel2bootc-var.conf").write_text("\n".join(tmpfiles_lines) + "\n")


def _render_containerfile_content(snapshot: InspectionSnapshot) -> str:
    """Build Containerfile content from snapshot."""
    lines = []
    base = _base_image_from_os_release(snapshot)
    lines.append("# === Base Image ===")
    os_desc = "unknown"
    if snapshot.os_release:
        os_desc = snapshot.os_release.pretty_name or snapshot.os_release.name or os_desc
    lines.append(f"# Detected: {os_desc}")
    lines.append(f"FROM {base}")
    lines.append("")

    # Repo configuration
    if snapshot.rpm and snapshot.rpm.repo_files:
        lines.append("# === Repository Configuration ===")
        lines.append(f"# Detected: {len(snapshot.rpm.repo_files)} repo file(s)")
        lines.append("COPY config/etc/yum.repos.d/ /etc/yum.repos.d/")
        if any("dnf" in r.path for r in snapshot.rpm.repo_files):
            lines.append("COPY config/etc/dnf/ /etc/dnf/")
        lines.append("")

    # Package installation
    if snapshot.rpm and snapshot.rpm.packages_added:
        names = sorted(set(p.name for p in snapshot.rpm.packages_added))
        lines.append("# === Package Installation ===")
        lines.append(f"# Detected: {len(names)} packages added beyond baseline")
        lines.append("RUN dnf install -y \\")
        for n in names[:-1]:
            lines.append(f"    {n} \\")
        lines.append(f"    {names[-1]} \\")
        lines.append("    && dnf clean all")
        lines.append("")

    # Service enablement
    if snapshot.services:
        enabled = snapshot.services.enabled_units
        disabled = snapshot.services.disabled_units
        if enabled or disabled:
            lines.append("# === Service Enablement ===")
            lines.append(f"# Detected: {len(enabled)} non-default enabled, {len(disabled)} disabled")
            if enabled:
                lines.append("RUN systemctl enable " + " ".join(enabled))
            if disabled:
                lines.append("RUN systemctl disable " + " ".join(disabled))
            lines.append("")

    # Configuration files
    if snapshot.config and snapshot.config.files:
        modified = [f for f in snapshot.config.files if f.kind == ConfigFileKind.RPM_OWNED_MODIFIED]
        unowned = [f for f in snapshot.config.files if f.kind == ConfigFileKind.UNOWNED]
        has_diffs = any(f.diff_against_rpm for f in snapshot.config.files)
        lines.append("# === Configuration Files ===")
        lines.append(f"# Detected: {len(modified)} modified RPM-owned configs, {len(unowned)} unowned configs")
        if has_diffs:
            lines.append("# Config diffs (--config-diffs): see audit-report.md and report.html for per-file diffs.")
        lines.append("COPY config/etc/ /etc/")
        lines.append("")

    # Firewall (when network has firewall data)
    if snapshot.network and snapshot.network.firewall_zones:
        lines.append("# === Firewall Configuration ===")
        lines.append(f"# Detected: {len(snapshot.network.firewall_zones)} firewall zone(s)/service(s)")
        lines.append("COPY config/etc/firewalld/ /etc/firewalld/")
        lines.append("")

    # Scheduled tasks (generated timer units from cron)
    if snapshot.scheduled_tasks and snapshot.scheduled_tasks.generated_timer_units:
        lines.append("# === Scheduled Tasks ===")
        lines.append(f"# Converted from cron: {len(snapshot.scheduled_tasks.generated_timer_units)} timer(s)")
        lines.append("COPY config/etc/systemd/system/ /etc/systemd/system/")
        for u in snapshot.scheduled_tasks.generated_timer_units:
            name = u.get("name", "")
            if name:
                lines.append(f"RUN systemctl enable {name}.timer")
        lines.append("")
    elif snapshot.scheduled_tasks and (snapshot.scheduled_tasks.systemd_timers or snapshot.scheduled_tasks.cron_jobs):
        lines.append("# === Scheduled Tasks ===")
        lines.append("# Cron jobs present; no generated timer units (empty cron.d or parse skipped)")
        lines.append("")

    # Non-RPM software
    if snapshot.non_rpm_software and snapshot.non_rpm_software.items:
        lines.append("# === Non-RPM Software ===")
        lines.append("# FIXME: verify installation method for each item")
        for i in snapshot.non_rpm_software.items[:20]:
            path = i.get("path", i.get("name", ""))
            lines.append(f"# COPY config/{path} /{path}")
        lines.append("")

    # Container workloads (quadlet)
    if snapshot.containers and (snapshot.containers.quadlet_units or snapshot.containers.compose_files):
        lines.append("# === Container Workloads (Quadlet) ===")
        if snapshot.containers.compose_files:
            lines.append("# FIXME: converted from docker-compose, verify quadlet translation")
        lines.append("COPY quadlet/ /etc/containers/systemd/")
        lines.append("")

    # Users and groups
    if snapshot.users_groups and (snapshot.users_groups.users or snapshot.users_groups.groups):
        lines.append("# === Users and Groups ===")
        for g in (snapshot.users_groups.groups or [])[:10]:
            name, gid = g.get("name", ""), g.get("gid", "")
            if name and gid:
                lines.append(f"RUN groupadd -g {gid} {name}")
        for u in (snapshot.users_groups.users or [])[:10]:
            name, uid, gid = u.get("name", ""), u.get("uid", ""), u.get("gid", "")
            if name and uid:
                gid_opt = f" -g {gid}" if gid else ""
                lines.append(f"RUN useradd -u {uid}{gid_opt} -m {name}")
        lines.append("")

    # Kernel configuration
    if snapshot.kernel_boot and snapshot.kernel_boot.cmdline:
        lines.append("# === Kernel Configuration ===")
        lines.append("# Detected: custom kernel args")
        lines.append("# RUN rpm-ostree kargs --append=...  # review and add as needed")
        lines.append("")

    # SELinux
    if snapshot.selinux and (snapshot.selinux.custom_modules or snapshot.selinux.boolean_overrides):
        lines.append("# === SELinux Customizations ===")
        lines.append("# Add COPY config/selinux/ and RUN semodule -i /tmp/selinux/*.pp if custom modules are in config/")
        lines.append("")

    # tmpfiles.d for /var structure
    lines.append("# === tmpfiles.d for /var structure ===")
    lines.append("# Directories created on every boot; /var is not updated by bootc after bootstrap.")
    lines.append("COPY config/etc/tmpfiles.d/ /etc/tmpfiles.d/")
    lines.append("")

    lines.append("# === Network / Kickstart ===")
    lines.append("# NOTE: Interface-specific config (DHCP, DNS) should be applied via kickstart at deploy time.")
    lines.append("")

    return "\n".join(lines)


def render(
    snapshot: InspectionSnapshot,
    env: Environment,
    output_dir: Path,
) -> None:
    """Write Containerfile and config/ tree to output_dir."""
    output_dir = Path(output_dir)
    output_dir.mkdir(parents=True, exist_ok=True)
    _write_config_tree(snapshot, output_dir)
    content = _render_containerfile_content(snapshot)
    (output_dir / "Containerfile").write_text(content)
